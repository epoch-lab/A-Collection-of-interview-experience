
#### Flow前端一面

1. webpack如何split代码，有几种方式
2. webpack如何进行tree shaking的配置
3. NPM依赖包版本号前缀~和^的区别
4. ssr和csr的区别
5. 如果用户能拿到数据请求url，如何进行反爬
6. rag的大致流程
7. langchain构建rag系统的流程
8. 流式输出的实现，前端后端分别如何做，用到了什么网络协议
9. sse的格式中，是用\n分隔还是用\n\n分隔，mime类型是啥
10. 手撕：流式输出的模拟实现
11. 手撕：带timeout的promise的实现

#### 字节Flow前端校招二面 1h

1. 大量元素更新，如何优化渲染
2. requestAnimationFrame原理
3. 介绍一下node_modules中的重复依赖问题，如何解决
4. 后端传来一个int64的数字到前端，会发生什么问题，如何解决
5. 介绍一下常见的设计模式，详细说说发布订阅模型
6. fetch之后的转json为什么是异步的，流式输出为何不需要转json
7. fetch如何打断请求
8. react合成事件是什么，和原生事件的触发顺序
9. 手撕：useRequest
10. 输出题：盒模型
11. 输出题：setState, setTimeout
12. 算法：两个栈实现队列
13. 算法：比较版本号

#### Flow前端校招三面 1h
1. display的属性，block, inline, inline-block的区别
2. 子元素宽度填满父元素的方法
3. encodeURI和encodeURIComponent的区别
4. xss原理和防范
5. 手撕：TS的returnType实现
6. 手撕：eventEmitter进阶版，支持once, group, priority
priority 用来控制同一事件监听器的执行先后顺序，group 用来批量管理和移除一组相关的监听器

7. 手撕：实现一个构造函数，对象中包含构造函数调用的次数（使用闭包）。进阶：1. 私有属性（get函数）2. 非new调用报错 3.不用闭包如何实现，是否了解类的静态变量
8. 项目：RAG项目的测试集是如何构造的，使用LLM构造测试集的优缺点

